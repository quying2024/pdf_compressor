# v2.0.2 重要修复和策略优化

## 发布日期
2025-10-19

## 问题发现
在 WSL/Ubuntu 24.04 环境下实测 156 页 136MB PDF 文件时发现以下问题：

### 1. **KeyError: 'size_mb'** (Critical Bug)
- **现象**：拆分策略启动时崩溃
- **原因**：`strategy.py` 中 `all_results` 字典使用 `'size'` 字段，但 `splitter.py` 期望 `'size_mb'` 字段
- **影响**：所有压缩失败后需要拆分的场景全部崩溃

### 2. **策略逻辑缺陷** (Logic Flaw)
- **问题1**：S6 结果 > 8MB 时仍继续尝试 S2-S5，浪费大量时间（实测压缩 136MB 文件耗时超 1 小时）
- **问题2**：没有智能目标切换机制，当原目标 2MB 无法达成但可以拆分时（2MB < size <= 8MB）应切换为 8MB 目标
- **问题3**：拆分策略未进行前置检查，即使没有 < 8MB 的结果仍尝试拆分

### 3. **S6 激进程度不足** (Performance Issue)
- 实测发现 S6 (DPI=110, BG-Downsample=6) 压缩 136MB → ~15MB，仍远大于 8MB
- 需要更激进的方案探索压缩极限

## 修复内容

### 🔧 核心修复

#### 1. 统一字段名称 (Critical)
**文件**: `compressor/strategy.py`

**修改**: 所有 `all_results` 字典统一使用 `'size_mb'` 字段
```python
# 修复前
all_results[1] = {'path': s1_result_path, 'size': s1_size_mb}

# 修复后
all_results[1] = {'path': s1_result_path, 'size_mb': s1_size_mb}
```

**影响行数**: 5 处修改
- Line 108: S1 结果
- Line 126: S7 结果
- Line 138: 回溯循环中
- Line 166: 顺序尝试循环中
- Line 185: 渐进式策略循环中

---

### ⚡ 策略优化

#### 2. S7 > 8MB 时直接失败
**文件**: `compressor/strategy.py` (Lines 128-131)

**新增逻辑**:
```python
# 关键检查：如果S7结果大于8MB，说明无法拆分，直接宣告失败
if s7_size_mb > 8.0:
    logging.error(f"❌ 最激进方案 S7 的结果 ({s7_size_mb:.2f}MB) 仍大于 8MB 拆分阈值，即使拆分也无法满足 2MB 目标，任务失败。")
    return None, all_results
```

**效果**: 避免无意义的 S2-S6 尝试，节省大量时间

#### 3. 智能目标切换：2MB → 8MB
**文件**: `compressor/strategy.py` (Lines 133-137)

**新增逻辑**:
```python
# 如果S7结果在2MB到8MB之间，切换目标为8MB（为拆分准备）
if target_size_mb < 8.0 and s7_size_mb > target_size_mb:
    logging.warning(f"⚠️ S7 结果 ({s7_size_mb:.2f}MB) 超过原目标 ({target_size_mb:.2f}MB) 但小于 8MB。")
    logging.info("🔄 策略调整：将目标切换为 8MB，寻找最接近 8MB 的方案用于后续拆分。")
    target_size_mb = 8.0
```

**效果**: 当直接压缩到 2MB 失败但可以拆分时，自动寻找最接近 8MB 的方案用于拆分

#### 4. 拆分前置条件检查
**文件**: `compressor/splitter.py` (Lines 23-32)

**新增逻辑**:
```python
# 前置检查：确保存在小于8MB的压缩结果
all_results = compression_results.get('all_results', {})
if not all_results:
    logging.error("❌ 拆分失败：没有任何压缩结果可用于拆分。")
    return False

under_8mb = [res for res in all_results.values() if res.get('size_mb', float('inf')) <= 8.0]
if not under_8mb:
    logging.error("❌ 拆分失败：所有压缩结果均大于 8MB，无法进行有效拆分。")
    return False

logging.info(f"✓ 找到 {len(under_8mb)} 个小于 8MB 的压缩结果，可以进行拆分。")
```

**效果**: 避免进入注定失败的拆分流程

---

### 🚀 性能增强

#### 5. 增强压缩方案激进程度
**文件**: `compressor/strategy.py` (Lines 10-18)

**修改**:
```python
# 定义从S1（最保守）到S7（最激进）的7个压缩方案
COMPRESSION_SCHEMES = {
    1: {'name': 'S1-保守', 'dpi': 300, 'bg_downsample': 2, 'jpeg2000_encoder': 'openjpeg'},
    2: {'name': 'S2-温和', 'dpi': 300, 'bg_downsample': 3, 'jpeg2000_encoder': 'grok'},
    3: {'name': 'S3-平衡', 'dpi': 250, 'bg_downsample': 3, 'jpeg2000_encoder': 'openjpeg'},
    4: {'name': 'S4-进取', 'dpi': 200, 'bg_downsample': 4, 'jpeg2000_encoder': 'grok'},
    5: {'name': 'S5-激进', 'dpi': 150, 'bg_downsample': 5, 'jpeg2000_encoder': 'openjpeg'},
    6: {'name': 'S6-极限', 'dpi': 100, 'bg_downsample': 8, 'jpeg2000_encoder': 'grok'},  # 增强
    7: {'name': 'S7-终极', 'dpi': 72, 'bg_downsample': 10, 'jpeg2000_encoder': 'grok'}, # 新增
}
```

**变更**:
- **S6 增强**: DPI 110→100, BG-Downsample 6→8
- **新增 S7**: DPI=72 (最低可读), BG-Downsample=10, 使用 grok 编码器

**目标**: 探索压缩极限，能够处理更大的 PDF 文件

---

## 代码变更统计

### 修改文件
1. `compressor/strategy.py` - 23 行修改
2. `compressor/splitter.py` - 12 行新增

### 关键变更点
- ✅ 修复 5 处字段名称不一致
- ✅ 新增 3 处智能判断逻辑
- ✅ 更新 1 个压缩方案定义
- ✅ 新增 1 个压缩方案
- ✅ 调整 3 处循环范围（2-6 → 2-7）

## 测试建议

### 1. 立即测试
重新测试原失败案例：
```bash
cd ~/pdf_compressor
python main.py -i testpdf156.pdf -o output -t 2 --allow-splitting
```

**预期结果**:
- S7 执行后立即判定成功/失败/切换目标
- 如果 S7 > 8MB，直接失败（无 S2-S6 尝试）
- 如果 2MB < S7 <= 8MB，切换目标为 8MB 并回溯
- 拆分策略有前置检查保护

### 2. 边界测试
- 测试 S7 = 7.5MB 的情况（应触发目标切换）
- 测试 S7 = 8.5MB 的情况（应直接失败）
- 测试 S7 = 1.5MB 的情况（应正常回溯）

### 3. 性能测试
对比修复前后处理 136MB PDF 的时间差异

## 待研究问题

### hOCR 文件对压缩的影响
用户提出的问题值得深入研究：

1. **不同 DPI 的 hOCR**
   - 当前所有方案使用 300 DPI 生成的 hOCR
   - 是否应该为低 DPI 方案生成对应 DPI 的 hOCR？
   - 影响方向：正向还是反向？

2. **空 hOCR 文件**
   - 研究显示空 hOCR（删除 OCR 文字内容，保留结构）可降低文件大小
   - 建议在 S7 方案中测试此技术
   - 需要实现 hOCR 清空功能

### 实现建议
```python
# 未来可考虑的增强
def _precompute_dar_steps_variable_dpi(input_pdf_path, temp_dir, scheme):
    """根据方案的 DPI 重新生成对应的 hOCR"""
    pass

def create_empty_hocr(hocr_file, output_file):
    """创建空 hOCR（仅保留结构，删除文字内容）"""
    pass
```

## 版本兼容性
- 向后兼容 v2.0.1
- 所有现有参数和接口保持不变
- 仅内部逻辑优化，无破坏性变更

## 升级路径
从 v2.0.1 直接升级：
```bash
git pull origin main
# 无需额外配置，直接使用
```

---

**发布类型**: Hotfix + Enhancement  
**优先级**: High  
**建议操作**: 立即升级并测试
